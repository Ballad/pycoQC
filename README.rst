
pycoQC
======

--------------

**pycoQC is a Python 3 package for Jupyter Notebook, computing metrics
and generating simple QC plots from Oxford Nanopore technologies (ONT)
Albacore basecaller** \_\_\_

pycoQC is a very simple quality control package for Nanopore data
written in pure python3, meant to be used directly in a jupyter notebook
4.0.0 +. As opposed to current and more exhaustive QC programs for
nanopore data, pycoQC is very fast as it relies entirely on the
*sequencing\_summary.txt* file generated by ONT Albacore Sequencing
Pipeline Software 1.2.1+, during base calling. Consequently, pycoQC will
only provide read level metrics (and not at base level)

At the time of the package writing, Albacore 1.2.1 generates a tabulated
file with the following fields 'filename', **'run\_id'**, **'channel**',
**'start\_time'**, **'duration'**, **'num\_events'**, 'template\_start',
'num\_events\_template', 'template\_duration', 'num\_called\_template',
**'sequence\_length\_template'**, **'mean\_qscore\_template'**,
'strand\_score\_template' (the fields in bold are used by pycoQC).

Please be aware that pycoQC is an experimental package that is still
under development. It was tested under Linux Ubuntu 16.04 and in an HPC
environment running under Red Hat Enterprise 7.1. You are welcome to
raise issues, contribute to the development and submit patches or
updates.

Installation
------------

Ideally, before installation, create a clean python3 virtual environment
to deploy the package, using virtualenvwrapper for example (see
http://www.simononsoftware.com/virtualenv-tutorial-part-2/).

Option 1: Direct installation with pip from github
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Install the package with pip. All the required dependencies will be
automatically installed.

.. code:: bash

    pip3 install git+https://github.com/a-slide/pycoQC.git

To update the package:

.. code:: bash

    pip3 install git+https://github.com/a-slide/pycoQC.git --upgrade

Option 2: Clone the repository and install locally in develop mode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With this option, the package will be locally installed in “editable” or
“develop” mode. This allows the package to be both installed and
editable in project form. This is the recommended option if you wish to
participate to the development of the package. As for the option before,
the required dependencies will be automatically installed.

.. code:: bash

    git clone https://github.com/a-slide/pycoQC.git
    cd pycoQC
    chmod u+x setup.py
    pip3 install -e ./

With this option you can also run the testing notebook located in the
source directory *pycoQC/test\_pycoQC.ipynb*

Option 3: Local installation without pip
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This option is also suitable if you are interested in further developing
the package, but requires a little bit more hands-on.

-  Clone the repository locally

.. code:: bash

    git clone https://github.com/a-slide/pycoQC.git

-  Add the package directory (./pycoQC/pycoQC) to you python3 PATH
   (depending on you OS and whether you want it to be permanent ot not)

-  Install the dependencies (numpy, pandas, matplotlib, seaborn and
   notebook)

.. code:: bash

    pip3 install numpy pandas matplotlib seaborn notebook

Usage
-----

The package is meant to be used in a jupyter notebook 4.0.0 +

Running jupyter in a virtualenv
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you installed the package in a virtual environment with
virtualenvwrapper, jupyter can run on the virtualenv:

-  Create a python3 virtualenv or activate an existing one

.. code:: bash

    mkvirtualenv --python=python3 virtualenv-name
    # Or
    workon virtualenv-name

-  Install the ipython kernel module into your virtualenv

.. code:: bash

    pip3 install ipykernel

-  Now run the kernel "self-install" script:

.. code:: bash

    python -m ipykernel install --user --name=virtualenv-name # Replacing the --name parameter as appropriate.

-  You should now be able to see your kernel in the IPython notebook
   menu: Kernel -> Change kernel and be able so switch to it (you may
   need to refresh the page before it appears in the list). IPython will
   remember which kernel to use for that notebook from then on.

Notebook setup
~~~~~~~~~~~~~~

-  Launch the notebook, navigate in the directory where you want to work
   and create a new python3 notebook

.. code:: bash

    jupyter notebook

-  Import pylab (from matplotlib + numpy) and use %pylab magic command
   to enable plotting in the current Notebook.

.. code:: ipython3

    import pylab as pl # Namespace containing numpy + matplotlib
    %pylab inline


.. parsed-literal::

    Populating the interactive namespace from numpy and matplotlib


-  Default pylab parameters can be defined at the beginning of the
   notebook as well (see http://matplotlib.org/users/customizing.html
   for more options)

.. code:: ipython3

    pl.rcParams['figure.figsize'] = 20,7
    pl.rcParams['font.family'] = 'sans-serif'
    pl.rcParams['font.sans-serif'] = ['DejaVu Sans']
    pl.style.use('ggplot')

Using pycoQC
~~~~~~~~~~~~

-  Import pycoQC main class

.. code:: ipython3

    from pycoQC.pycoQC import pycoQC as pcq


-  A sample test file generated by Albacore can be obtained from the
   package data using *pkg\_resources*, or you can use your own file

.. code:: ipython3

    from pkg_resources import Requirement, resource_filename
    sequencing_summary_file = resource_filename(Requirement.parse("pycoQC"),'pycoQC/data/sequencing_summary.txt')

-  Load the sequencing\_summary file (verbose mode will give you
   additional information while parsing the file)

.. code:: ipython3

    p = pcq(sequencing_summary_file)
    print(p)


.. parsed-literal::

    pycoQC instance
    	Parameters list
    	runid	ad3de3b63de71c4c6d5ea4470a82782cf51210d9
    	seq_summary_file	/home/aleg/Programming/Python3/pycoQC/pycoQC/data/sequencing_summary.txt
    	total_reads	126583
    	verbose	False
    


-  Generate a basic overview of the data using the *overview* function

.. code:: ipython3

    p.overview()



.. raw:: html

    <div>
    <style>
        .dataframe thead tr:only-child th {
            text-align: right;
        }
    
        .dataframe thead th {
            text-align: left;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Count</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>Reads</th>
          <td>126583</td>
        </tr>
        <tr>
          <th>Bases</th>
          <td>1182258096</td>
        </tr>
        <tr>
          <th>Events</th>
          <td>2171928526</td>
        </tr>
        <tr>
          <th>Active Channels</th>
          <td>507</td>
        </tr>
        <tr>
          <th>Run Duration (h)</th>
          <td>47.9615</td>
        </tr>
      </tbody>
    </table>
    </div>



.. raw:: html

    <div>
    <style>
        .dataframe thead tr:only-child th {
            text-align: right;
        }
    
        .dataframe thead th {
            text-align: left;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>Quality score distribution</th>
          <th>Read length distribution</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>count</th>
          <td>126583.000000</td>
          <td>126583.000000</td>
        </tr>
        <tr>
          <th>mean</th>
          <td>10.999623</td>
          <td>9339.785722</td>
        </tr>
        <tr>
          <th>std</th>
          <td>2.093108</td>
          <td>12618.058576</td>
        </tr>
        <tr>
          <th>min</th>
          <td>2.347000</td>
          <td>5.000000</td>
        </tr>
        <tr>
          <th>10%</th>
          <td>7.649000</td>
          <td>732.000000</td>
        </tr>
        <tr>
          <th>25%</th>
          <td>9.534000</td>
          <td>2053.000000</td>
        </tr>
        <tr>
          <th>50%</th>
          <td>11.526000</td>
          <td>3518.000000</td>
        </tr>
        <tr>
          <th>75%</th>
          <td>12.672000</td>
          <td>10887.000000</td>
        </tr>
        <tr>
          <th>90%</th>
          <td>13.300000</td>
          <td>28927.800000</td>
        </tr>
        <tr>
          <th>max</th>
          <td>15.310000</td>
          <td>49917.000000</td>
        </tr>
      </tbody>
    </table>
    </div>



.. image:: extra/output_46_2.png


-  Low/high quality and short/long reads can be excluded from the
   subsequent analyses

.. code:: ipython3

    p.trim_read_len(min_len=25)


.. parsed-literal::

    177 short reads were removed


.. code:: ipython3

    p.trim_read_qual(min_qual=5)


.. parsed-literal::

    50 low quality reads were removed


Plots can be generated by calling the pycoCQ object with one of the 6
available plotting functions.

Each function has specific options that are comprehensively detailed in
the testing notebook provided with the package or in html version on
nbviewer: `link to
test\_notebook <https://nbviewer.jupyter.org/github/a-slide/pycoQC/blob/master/pycoQC/test_pycoQC.ipynb?flush_cache=true>`__

.. code:: ipython3

    g = p.channels_activity()



.. image:: extra/output_51_0.png


.. code:: ipython3

    g = p.mean_qual_distribution()



.. image:: extra/output_52_0.png


.. code:: ipython3

    g = p.output_over_time()



.. image:: extra/output_53_0.png


.. code:: ipython3

    g = p.quality_over_time()



.. image:: extra/output_54_0.png


.. code:: ipython3

    g = p.reads_len_distribution()



.. image:: extra/output_55_0.png


.. code:: ipython3

    g = p.reads_len_quality()



.. image:: extra/output_56_0.png


Authors and Contact
-------------------

Adrien Leger - 2017

Enright's group, EMBL EBI

-  aleg@ebi.ac.uk
-  `Github <https://github.com/a-slide>`__
