# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~IMPORTS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

# Standard library imports
from collections import *
import warnings
import datetime
import os

# Third party imports
import pandas as pd

# Local lib import
from pycoQC.common import *
from pycoQC import __name__ as package_name
from pycoQC import __version__ as package_version

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~GLOBAL SETTINGS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

# Silence futurewarnings
warnings.filterwarnings("ignore", category=FutureWarning)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MAIN CLASS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
def Barcode_split (
    summary_file:str,
    output_dir:str="",
    output_unclassified:bool=False,
    min_barcode_percent:float=0.1,
    verbose:bool=False,
    quiet:bool=False):
    """
    Parse Albacore sequencing_summary.txt file and split per barcode
    By default, data for low frequency barcodes and unclassified reads are not written in the output directory
    * summary_file
        Path to a sequencing_summary generated by Albacore 1.0.0 + (read_fast5_basecaller.py) / Guppy 2.1.3+ (guppy_basecaller).
        One can also pass multiple space separated file paths or a UNIX style regex matching multiple files
    * output_dir
        Folder where to output split barcode data
    * output_unclassified
        If True unclassified barcodes are also written in a file. By default they are skiped
    * min_barcode_percent
        Minimal percent of total reads to retain barcode label. If below the barcode value is set as `unclassified`.
    * verbose
        Increase verbosity
    * quiet
        Reduce verbosity
    """

    # Save args and init options in dict for report
    options_d = locals()
    info_d = {"package_name":package_name, "package_version":package_version, "timestamp":str(datetime.datetime.now())}

    # Set logging level
    logger = get_logger (name=__name__, verbose=verbose, quiet=quiet)

    # Print debug info
    logger.debug("General info")
    logger.debug(dict_to_str(info_d))
    logger.debug("Runtime options")
    logger.debug(dict_to_str(options_d))

    # Process data
    logger.warning ("Import data from sequencing summary file(s) and cleanup")
    logger.info ("\tExpand file names list")
    fn_list = expand_file_names(summary_file)
    logger.info ("\tRead files and import in a dataframe")
    df = merge_files_to_df (fn_list)

    if not "barcode_arrangement" in df:
        raise pycoQCError ("No barcode information found in provided file(s)")

    # Quick data cleanup
    logger.info ("\tCleanup missing barcodes values")
    df = df.fillna({"barcode_arrangement":"unclassified"})

    # Filter out barcodes with low frequency
    if min_barcode_percent:
        logger.info ("\tCleaning up low frequency barcodes")
        barcode_counts = df["barcode_arrangement"][df["barcode_arrangement"]!="unclassified"].value_counts()
        cutoff = int(barcode_counts.sum()*min_barcode_percent/100)
        low_barcode = barcode_counts[barcode_counts<cutoff].index
        df.loc[df["barcode_arrangement"].isin(low_barcode), "barcode_arrangement"] = "unclassified"

    barcode_c = Counter()
    logger.warning ("Split data per barcode")
    for barcode, b_df in df.groupby("barcode_arrangement"):
        logger.info ("\tProcessing data for Barcode {}".format(barcode))
        barcode_c[barcode] = len(b_df)

        # Skip unclassified not required
        if barcode == "unclassified" and not output_unclassified:
            continue

        # Else wrie in file
        b_df_name = os.path.join(output_dir, "sequencing_summary_{}.txt".format(barcode))
        b_df = b_df[[i for i in df.columns if not i.startswith("barcode")]]
        b_df.to_csv(b_df_name, sep="\t", index=False)

    logger.info("Barcode Counts")
    logger.info(dict_to_str(barcode_c))
