
# pycoQC

___
**pycoQC is a Python 3 package for Jupyter Notebook, computing metrics and generating simple QC plots from Oxford Nanopore technologies (ONT) Albacore basecaller**
___

pycoQC is a very simple quality control package for Nanopore data written in pure python3, meant to be used directly in a jupyter notebook 4.0.0 +. As opposed to current and more exhaustive QC programs for nanopore data, pycoQC is very fast as it relies entirely on the *sequencing_summary.txt* file generated by ONT Albacore Sequencing Pipeline Software 1.2.1+, during base calling. Consequently, pycoQC will only provide read level metrics (and not at base level)

At the time of the package writing, Albacore 1.2.1 generates a tabulated file  with the following fields 'filename', **'run_id'**, **'channel**', **'start_time'**, **'duration'**, **'num_events'**, 'template_start', 'num_events_template', 'template_duration', 'num_called_template', **'sequence_length_template'**, **'mean_qscore_template'**, 'strand_score_template' (the fields in bold are used by pycoQC).

Please be aware that pycoQC is an experimental package that is still under development. It was tested under Linux Ubuntu 16.04 and in an HPC environment running under Red Hat Enterprise 7.1. You are welcome to raise issues, contribute to the development and submit patches or updates.

## Installation

Ideally, before installation, create a clean python3 virtual environment to deploy the package, using virtualenvwrapper for example (see http://www.simononsoftware.com/virtualenv-tutorial-part-2/).

### Option 1: Direct installation with pip from github

Install the package with pip. All the required dependencies will be automatically installed.


```bash
pip3 install git+https://github.com/a-slide/pycoQC.git
```

To update the package:


```bash
pip3 install git+https://github.com/a-slide/pycoQC.git --upgrade
```

### Option 2: Clone the repository and install locally in develop mode

With this option, the package will be locally installed in “editable” or “develop” mode. This allows the package to be both installed and editable in project form. This is the recommended option if you wish to participate to the development of the package. As for the option before, the required dependencies will be automatically installed.


```bash
git clone https://github.com/a-slide/pycoQC.git
cd pycoQC
chmod u+x setup.py
pip3 install -e ./
```

With this option you can also run the testing notebook located in the source directory *pycoQC/test_pycoQC.ipynb*

### Option 3: Local installation without pip 

This option is also suitable if you are interested in further developing the package, but requires a little bit more hands-on.

* Clone the repository locally


```bash
git clone https://github.com/a-slide/pycoQC.git
```

* Add the package directory (./pycoQC/pycoQC) to you python3 PATH (depending on you OS and whether you want it to be permanent ot not)

* Install the dependencies (numpy, pandas, matplotlib, seaborn and notebook)


```bash
pip3 install numpy pandas matplotlib seaborn notebook
```

## Usage

The package is meant to be used in a jupyter notebook 4.0.0 +

### Running jupyter in a virtualenv

If you installed the package in a virtual environment with virtualenvwrapper, jupyter can run on the virtualenv:

* Create a python3 virtualenv or activate an existing one


```bash
mkvirtualenv --python=python3 virtualenv-name
# Or
workon virtualenv-name
```

* Install the ipython kernel module into your virtualenv


```bash
pip3 install ipykernel
```

* Now run the kernel "self-install" script:


```bash
python -m ipykernel install --user --name=virtualenv-name # Replacing the --name parameter as appropriate.
```

* You should now be able to see your kernel in the IPython notebook menu: Kernel -> Change kernel and be able so switch to it (you may need to refresh the page before it appears in the list). IPython will remember which kernel to use for that notebook from then on.

### Notebook setup

* Launch the notebook, navigate in the directory where you want to work and create a new python3 notebook


```bash
jupyter notebook
```

* Import pylab (from matplotlib + numpy) and use %pylab magic command to enable plotting in the current Notebook.


```python
import pylab as pl # Namespace containing numpy + matplotlib
%pylab inline
```

    Populating the interactive namespace from numpy and matplotlib


* Default pylab parameters can be defined at the beginning of the notebook as well (see http://matplotlib.org/users/customizing.html for more options)


```python
pl.rcParams['figure.figsize'] = 20,7
pl.rcParams['font.family'] = 'sans-serif'
pl.rcParams['font.sans-serif'] = ['DejaVu Sans']
pl.style.use('ggplot')
```

### Using pycoQC

* Import pycoQC main class


```python
from pycoQC.pycoQC import pycoQC as pcq
```

    /home/aleg/.virtualenvs/test_setup_py3/lib/python3.5/site-packages/IPython/html.py:14: ShimWarning: The `IPython.html` package has been deprecated since IPython 4.0. You should import from `notebook` instead. `IPython.html.widgets` has moved to `ipywidgets`.
      "`IPython.html.widgets` has moved to `ipywidgets`.", ShimWarning)


* A sample test file generated by Albacore can be obtained from the package data using *pkg_resources*, or you can use your own file


```python
from pkg_resources import Requirement, resource_filename
sequencing_summary_file = resource_filename(Requirement.parse("pycoQC"),'pycoQC/data/sequencing_summary.txt')
```

* Load the sequencing_summary file (verbose mode will give you additional information while parsing the file)


```python
p = pcq(sequencing_summary_file)
print(p)
```

    pycoQC instance
    	Parameters list
    	runid_counts	                                          Counts
    ad3de3b63de71c4c6d5ea4470a82782cf51210d9  126583
    7082b6727942b3939a023beaf03ef24cec1722e5    1013
    	seq_summary_file	/home/aleg/Programming/Python3/pycoQC/pycoQC/data/sequencing_summary.txt
    	total_reads	127596
    	verbose	False
    


* Generate a basic overview of the data using the *overview* function


```python
p.overview()
```


<p><b>General counts</b></p>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Reads</th>
      <td>127596</td>
    </tr>
    <tr>
      <th>Bases</th>
      <td>1188408969</td>
    </tr>
    <tr>
      <th>Events</th>
      <td>2182224107</td>
    </tr>
    <tr>
      <th>Active Channels</th>
      <td>507</td>
    </tr>
    <tr>
      <th>Run Duration (h)</th>
      <td>47.9618</td>
    </tr>
  </tbody>
</table>



<p><b>Read count per Run ID</b></p>


<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Counts</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>ad3de3b63de71c4c6d5ea4470a82782cf51210d9</th>
      <td>126583</td>
    </tr>
    <tr>
      <th>7082b6727942b3939a023beaf03ef24cec1722e5</th>
      <td>1013</td>
    </tr>
  </tbody>
</table>


<p><b>Distribution of quality scores and read lengths</b></p>


<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Quality score distribution</th>
      <th>Read length distribution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>127596.000000</td>
      <td>127596.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>11.009888</td>
      <td>9313.841884</td>
    </tr>
    <tr>
      <th>std</th>
      <td>2.093662</td>
      <td>12589.088614</td>
    </tr>
    <tr>
      <th>min</th>
      <td>2.347000</td>
      <td>5.000000</td>
    </tr>
    <tr>
      <th>10%</th>
      <td>7.668000</td>
      <td>733.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>9.547750</td>
      <td>2054.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>11.535000</td>
      <td>3517.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>12.682000</td>
      <td>10831.250000</td>
    </tr>
    <tr>
      <th>90%</th>
      <td>13.309000</td>
      <td>28804.500000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>15.310000</td>
      <td>49917.000000</td>
    </tr>
  </tbody>
</table>



![png](extra/output_46_6.png)


* Low/high quality and short/long reads can be excluded from the subsequent analyses  

Plots can be generated by calling the pycoCQ object with one of the 6 available plotting functions.

Each function has specific options that are comprehensively detailed in the testing notebook provided with the package or in html version on nbviewer: [link to test_notebook](https://nbviewer.jupyter.org/github/a-slide/pycoQC/blob/master/pycoQC/test_pycoQC.ipynb?flush_cache=true)


```python
g = p.channels_activity()
```


![png](extra/output_49_0.png)



```python
g = p.mean_qual_distribution()
```


![png](extra/output_50_0.png)



```python
g = p.output_over_time()
```


![png](extra/output_51_0.png)



```python
g = p.quality_over_time()
```


![png](extra/output_52_0.png)



```python
g = p.reads_len_distribution()
```


![png](extra/output_53_0.png)



```python
g = p.reads_len_quality()
```


![png](extra/output_54_0.png)


## Authors and Contact

Adrien Leger - 2017

Enright's group, EMBL EBI

* <aleg@ebi.ac.uk>
* [Github](https://github.com/a-slide)
